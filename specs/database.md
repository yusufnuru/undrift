# Database

## Overview

Focus Guard v2 replaces the single-table DynamoDB payment schema with a multi-table schema for user accounts, time tracking, session history, and streaks. The previous `FocusGuardPayments` table is deprecated.

---

## Provider Options

### Option A: PostgreSQL (Recommended)

- Relational model fits the structured, queryable nature of analytics data
- Rich aggregation queries for dashboard (GROUP BY date, SUM time, etc.)
- Hosted options: Supabase, Railway, Neon, AWS RDS
- Strong ecosystem for Go (`pgx` driver)

### Option B: DynamoDB (Current)

- Already in use from v1
- Good for simple key-value lookups
- Awkward for analytics queries (scans, no JOINs, limited aggregation)
- Would require heavy GSI usage and client-side computation

**Recommendation:** Migrate to PostgreSQL. The dashboard's analytics queries (time aggregation, date ranges, ranking) are natural SQL but painful in DynamoDB.

---

## Schema (PostgreSQL)

### Table: `users`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | User ID |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | User email |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Account creation |
| `last_seen_at` | TIMESTAMPTZ | | Last sync from extension |

### Table: `time_tracking`

Daily per-domain time aggregation. One row per user per domain per day.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | BIGSERIAL | PRIMARY KEY | Auto-increment |
| `user_id` | UUID | FK → users(id), NOT NULL | |
| `date` | DATE | NOT NULL | Calendar day |
| `domain` | VARCHAR(255) | NOT NULL | e.g., "youtube.com" |
| `seconds` | INTEGER | NOT NULL, DEFAULT 0 | Total seconds on this domain today |

**Unique constraint:** `(user_id, date, domain)` — upsert on sync

**Indexes:**
- `idx_time_tracking_user_date` on `(user_id, date)` — dashboard date range queries
- `idx_time_tracking_user_domain` on `(user_id, domain)` — per-site analytics

### Table: `sessions`

One row per focus session.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Session UUID (generated by extension) |
| `user_id` | UUID | FK → users(id), NOT NULL | |
| `started_at` | TIMESTAMPTZ | NOT NULL | Session start |
| `ended_at` | TIMESTAMPTZ | | Session end (null if active) |
| `duration_minutes` | INTEGER | NOT NULL | Configured duration |
| `blocked_sites` | TEXT[] | NOT NULL | Array of blocked domains |
| `end_reason` | VARCHAR(20) | | `timer`, `manual`, `browser_closed` |
| `completed` | BOOLEAN | DEFAULT FALSE | Did it run to completion? |

**Indexes:**
- `idx_sessions_user_started` on `(user_id, started_at DESC)` — session history listing

### Table: `interruptions`

One row per attempt to visit a blocked site during a session.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | BIGSERIAL | PRIMARY KEY | Auto-increment |
| `session_id` | UUID | FK → sessions(id), NOT NULL | |
| `user_id` | UUID | FK → users(id), NOT NULL | Denormalized for query efficiency |
| `timestamp` | TIMESTAMPTZ | NOT NULL | When the attempt happened |
| `domain` | VARCHAR(255) | NOT NULL | Which blocked site |
| `outcome` | VARCHAR(10) | NOT NULL | `stayed` or `broke` |

**Indexes:**
- `idx_interruptions_session` on `(session_id)` — per-session detail view
- `idx_interruptions_user` on `(user_id, timestamp DESC)` — user analytics

### Table: `streaks`

One row per user. Updated on session completion.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `user_id` | UUID | PRIMARY KEY, FK → users(id) | |
| `current_streak` | INTEGER | DEFAULT 0 | Current consecutive days |
| `longest_streak` | INTEGER | DEFAULT 0 | All-time best |
| `streak_start_date` | DATE | | When current streak began |
| `last_completed_date` | DATE | | Last day a session was completed |

### Table: `reflections`

Journal entries from the intervention page.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | BIGSERIAL | PRIMARY KEY | Auto-increment |
| `user_id` | UUID | FK → users(id), NOT NULL | |
| `timestamp` | TIMESTAMPTZ | NOT NULL | When submitted |
| `domain` | VARCHAR(255) | NOT NULL | Which blocked site triggered this |
| `prompt` | TEXT | NOT NULL | The question shown |
| `response` | TEXT | NOT NULL | User's answer |
| `urge_level` | SMALLINT | | 1-10 scale (nullable) |

### Table: `settings`

User preferences synced between extension and dashboard.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `user_id` | UUID | PRIMARY KEY, FK → users(id) | |
| `personal_reason` | TEXT | | Why the user wants to focus |
| `blocked_presets` | TEXT[] | | Selected preset site categories |
| `custom_sites` | TEXT[] | | User-added custom domains |
| `notification_prefs` | JSONB | | Notification settings object |
| `updated_at` | TIMESTAMPTZ | DEFAULT NOW() | Last update |

---

## Key Queries

### Dashboard Overview

```sql
-- Today's total screen time
SELECT SUM(seconds) FROM time_tracking
WHERE user_id = $1 AND date = CURRENT_DATE;

-- Top sites this week
SELECT domain, SUM(seconds) as total
FROM time_tracking
WHERE user_id = $1 AND date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY domain ORDER BY total DESC LIMIT 10;

-- Session completion rate (last 30 days)
SELECT
  COUNT(*) FILTER (WHERE completed) as completed,
  COUNT(*) as total
FROM sessions
WHERE user_id = $1 AND started_at >= NOW() - INTERVAL '30 days';

-- Most tempting sites
SELECT domain, COUNT(*) as attempts
FROM interruptions
WHERE user_id = $1
GROUP BY domain ORDER BY attempts DESC LIMIT 5;

-- Weekly time trend
SELECT date, SUM(seconds) as total
FROM time_tracking
WHERE user_id = $1 AND date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY date ORDER BY date;
```

### Sync Upsert

```sql
-- Upsert time tracking (extension sends daily totals)
INSERT INTO time_tracking (user_id, date, domain, seconds)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, date, domain)
DO UPDATE SET seconds = EXCLUDED.seconds;
```

---

## Client-Side Storage

The Chrome extension uses local storage as the primary data store. Server sync is optional (requires account).

### `chrome.storage.local`

| Key | Type | Content |
|-----|------|---------|
| `session` | object | `{ isActive, endsAt, blockedSites, sessionId, interruptions[] }` |
| `selectedPresets` | string[] | Names of selected preset categories |
| `customSites` | string[] | User-added custom domains |
| `timeTracking` | object | `{ daily: { [date]: { [domain]: seconds } }, current: { domain, startedAt } }` |
| `sessionHistory` | object | `{ sessions: FocusSession[], lastSyncedAt: number }` |
| `streak` | object | `{ currentStreak, longestStreak, lastCompletedDate, streakStartDate }` |
| `reflections` | array | `Reflection[]` |
| `notificationState` | object | Deduplication tracking for sent notifications |

### `chrome.storage.sync` (cross-device)

| Key | Type | Content |
|-----|------|---------|
| `userId` | string | UUID v4 |
| `authToken` | string | JWT (if logged into dashboard) |
| `personalReason` | string | User's stated motivation |
| `notificationSettings` | object | Notification preferences |

---

## Migration from v1

### What to Remove

- `FocusGuardPayments` DynamoDB table — no longer needed
- `Payment` struct in Go server
- All payment-related DynamoDB operations (`savePayment`, `markPaymentPaid`, `checkPaymentPaid`, `getPaymentsByUser`)

### What to Add

- PostgreSQL connection in Go server (using `pgx` driver)
- Migration scripts for schema creation
- Sync handler that upserts time tracking and session data
